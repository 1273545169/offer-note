#链接
------- 
>牛客OJ：[数组中重复的数字](http://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)


#题意
-------


**题目描述**

>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 
>
>数组中某些数字是重复的，但不知道有几个数字是重复的。
>
>也不知道每个数字重复几次。请找出数组中任意一个重复的数字。
>
>例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。

**样例输入**

>2, 3, 1, 0, 2, 5, 3
>
> 2, 1, 3, 1, 4


**样例输出**

>2
>
>1

#检查数据的合法性 
-------

*    检查输入参数是否合法

*    数组中的数据是否满足所有数字都在0到n-1的范围内

```cpp
bool CheckValidity(int *numbers, int length)
{
    //  输入数据不合法
    if(numbers == NULL || length <= 0)
    {
        return false;
    }

    //  元素必须在[0, n-1]的范围
    for(int i = 0; i < length; i++)
    {
        if(numbers[i] < 0 || numbers[i] > length - 1)
        {
            return false;
        }
    }

    return true;
}
```
#利用内外两层循环来判断重复
--------
```cpp

class Solution {
public:
    bool duplicate(int numbers[], int length, int* duplication)
    {
    
// 计算数组的长度
// int length = sizeof(numbers)/sizeof(numbers[0]);

        *duplication =-1;
        bool isDup=false;
        
        if(!CheckValidity(numbers,length))
        {
            return false;
        }
//核心
        for(int i =0; i<length-1; i++)
        {
            for(int j =i+1;j<length;j++)
            {
                if(numbers[i]==numbers[j])
                {
                    isDup= true;
                    *duplication=numbers[i];
                    return isDup;
                    
                }
            }
        }
        return isDup;

    }
};

```

#排序后判断重复
-------

最简单的思路就是先把输入的数组排序。从排序的数组中找出重复的数字就是个很容易的事情了。只需要从头向尾扫描一遍排序好的数组即可。

对一个数组排序的时间复杂度是$O(nlogn)$

扫描一个排序好的数组发现重复的数字的时间复杂度是$O(n)$


```cpp
        sort(numbers, numbers + length);    //  对数组进行排序
        //  扫描一遍数组发现重复的数字
        for(int i = 0; i < length - 1; i++)
        {
            if(numbers[i] == numbers[i + 1])    //  重复了
            {
                isDup = true;
                *duplication = numbers[i];
                break;
            }
        }

```

**#c++ set容器**
--------
set容器中元素唯一，按照一定的顺序排列。可快速检索，时间复杂度为O（1）
s.count(value)判断value在s中出现的次数，结果为0或者1。


```cpp
     set<int> s;
     for(int i =0; i<length; i++)
        {
            if(s.count(numbers[i])==1)
            {
                isDup=true;
                *duplication = numbers[i];
                break;
            }
            s.insert(numbers[i]);
        }
       
```

**#把元素放在自己该在的位置**
--------

我们考虑如果每个数字都置出现一次，那么此时是最完美的，每一个下标i对应元素numbers[i]，也就是说我们对于数组中的每个元素numbers[i]都把它放在自己应该在的位置上numbers[numbers[i]]上, 如果这两个值相等，说明此元素必然重复

即如下的过程

1、如果numbers[i] == i, 那么我们认为number[i]这个元素是在自己的位置上的

2、否则numbers[i]这个元素就应该在numbers[numbers[i]]这个位置上,如果numbers[i] == numbers[numbers[i]]，元素重复 

3、否则交换numbers[i]和numbers[numbers[i]]

```cpp

  for(int i=0;i<length;i++)
        {
            if (numbers[i]!=i)
            {
                if (numbers[i]==numbers[numbers[i]])
                {
                    isDup=true;
                    *duplication=numbers[i];
                    break;
                }
                swap(numbers[i],numbers[numbers[i]]);
            }


        }

```
