**#排序算法有：冒泡排序、插入排序、归并排序、快速排序**

> 插入排序和冒泡排序在平均和最坏情况下的时间复杂度都是 O(n^2)，最好情况下都是 O(n)，空间复杂度是 O(1)。
> 快速排序平均情况下快速排序的时间复杂度是Θ(nlgn)，最坏情况是n2，但通过随机算法可以避免最坏情况。由于递归调用，快排的空间复杂度是Θ(lgn)。

**#（1）冒泡排序**

冒泡排序的基本思想就是：从无序序列头部开始，进行两两比较，根据大小交换位置，直到最后将最大（小）的数据元素交换到了无序序列的队尾，从而成为有序序列的一部分；下一次继续这个过程，直到所有数据元素都排好序。

算法的核心在于每次通过两两比较交换位置，选出剩余无序序列里最大（小）的数据元素放到队尾。

``` 
#把最大的元素放在队末
void bubble_sort(int arr[], int len) 
{
    for(int i=lenth-1;i>0;i++)
    {
        for(int j=0;j<i;j++)
        {

            if(a[j]>a[j+1])
            {
                swap(a[j],a[j+1]);

            }
        }
    }


}


**#（2）直接插入排序**

直接插入排序的基本思想是：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
实现思路是：
1、认为第一个元素是排好序的，从第二个开始遍历；
2、拿出当前元素的值，从排好序的序列中从后往前找；
3、如果序列中的元素比当前元素大，将其后移。直到找到一个小的；
4、把当前元素放在这个小的后面（后面的比当前大，它已经被后移了）。

```
void insertion_sort(int arr[],int len)
{
    for(int i=1;i<len;i++)
    {
        //key待排序元素
        int key = arr[i];
        int j;
        //序列中的元素比当前元素大，将其后移
        for(j=i-1;j>=0 && arr[j]>key;j--)
        {
            arr[j+1]=arr[j];
        }
        #将待排序元素插入到有序序列中
        arr[j+1]=key;

    }
}

```
**#（3）快速排序**
快速排序使用分治法（Divide and conquer）策略来把一个序列分为两个子序列。
1、在序列中选取一个基准元素（pivot）
2、比pivot小的放到pivot左边，比pivot大的放到pivot右边
3、对pivot左边的序列和右边的序列分别递归的执行步骤1和步骤2
```

```

参考：https://harttle.land/2015/09/28/insertion-bubble-sort.html
